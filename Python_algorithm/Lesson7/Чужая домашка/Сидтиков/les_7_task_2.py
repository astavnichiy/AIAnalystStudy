# Vasilii Sitdikov
# GeekBrains Courses. Algorithms
# Lesson 7 task 2
# October 2019

# task: 2 Отсортируйте по возрастанию методом слияния одномерный вещественный массив,заданный случайными числами
#       на промежутке [0; 50). Выведите на экран исходный и отсортированный массивы.
# ----------------------------------------------------------------------------------------------------------------------

from random import random


def in_place_merger(a, l, m, h):
    """
    Первая вспомогательная функция "объединяет" два сортированных участка внутри массива
    :param a: Передаваемый в функию массив
    :param l: Индекс первого элемента первого сортированного участка
    :param m: Индекс последнего элемента первого сортированного участка
    :param h: Индекс последнего элемента второго сортированного участка
    :return: Массив, отсортированный по возрастанию только от элемента l до элемента h (не возвращается через return)
    """
    c = a[l:h + 1]  # Вспомогательный массив - копия сортированных участков
#    print(c)   Снимите комментарий к этой строке, чтобы наглядно увидеть порядок работы функции merge_sort

    cm = m - l + 1  # Длина первой отсортированной части
    ch = h - l + 1  # Длина обоих частей
    i = 0  # Счетчик позиции в первой сортированной части
    j = cm  # Счетчик позиции во второй сортированной части
    for k in range(l, h + 1):
        if i >= cm:  # Если прошли всю первую часть, вторую просто приклееваем, элементы больше не сравниваем
            a[k] = c[j]
            j += 1
        elif j >= ch:  # Если прошли всю вторую часть, первую просто приклееваем, элементы больше не сравниваем
            a[k] = c[i]
            i += 1
        elif c[i] <= c[j]:  # При сравнении элементов "забираем" меньший
            a[k] = c[i]
            i += 1
        else:
            a[k] = c[j]
            j += 1


def merge_sort(a, l, h):
    """
    Рекурсивная функция, использует функцию in_place_merger к уже упорядоченным участкам.
    Изначально уже упорядоченным участком считается каждый отдельный элемент
    Первая вспомогательная функция "объединяет" два сортированных участка внутри массива
    :param a: Передаваемый в функию массив
    :param l: Индекс первого элемента первого сортированного участка
    :param h: Индекс последнего элемента второго сортированного участка
    :return: Массив, отсортированный по возрастанию только от элемента l до элемента h (не возвращается через return)
    """
    if l < h:
        m = l + (h - l) // 2
        merge_sort(a, l, m)
        merge_sort(a, m + 1, h)
        in_place_merger(a, l, m, h)


def my_merge_sort(a):
    """
    Пользовательская оболочка. Вызывает функцию merge_sort, передавая в качестве l и h начало и конец массива
    :param a: Передаваемый в функию массив
    :return: Отсортированный массив (не возвращается через return)
    """
    merge_sort(a, 0, len(a) - 1)


def test(n):
    for i in range(1, 11):
        print('*' * 50)
        print(f'Test {i:}')
        test_list = [round(random() * 50, 2) for _ in range(n)]
        print(f'Tested list: {test_list}')
        sort_list = sorted(test_list)
        my_merge_sort(test_list)
        print(f'Sorted list: {test_list}')
        assert sort_list == test_list
        print('Test completed successfully')


test(20)
